---
phase: 04-code-quality
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - EIDCardLibrary/StoredCredentialManagement.cpp
  - EIDCardLibrary/StoredCredentialManagement.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Internal buffer handling functions use std::span for bounds-safe access"
    - "Exported API boundaries maintain C-style signatures (PBYTE, DWORD size)"
    - "No std::span stored in class members (lifetime safety)"
    - "Code compiles successfully with C++23 after changes"
  artifacts:
    - path: "EIDCardLibrary/StoredCredentialManagement.h"
      provides: "Internal function declarations using std::span"
      contains: "std::span"
    - path: "EIDCardLibrary/StoredCredentialManagement.cpp"
      provides: "Internal function implementations with std::span usage"
      contains: "std::span"
  key_links:
    - from: "StoredCredentialManagement::StorePrivateData"
      to: "InternalProcessSecretData"
      via: "std::span wrapper conversion"
      pattern: "std::span.*pbSecret"
    - from: "Internal functions"
      to: "std::span"
      via: "Direct usage for bounds-safe iteration"
      pattern: "for.*auto.*:.*span"
---

<objective>
Introduce std::span for safe buffer handling in credential storage functions

Purpose: std::span provides bounds-safe buffer views without ownership. By using span at internal function boundaries, we get automatic size tracking and range-based for loops while maintaining C-style API exports for Windows compatibility.

Output: Internal functions use std::span, exported functions maintain C-style signatures
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-code-quality/04-RESEARCH.md
@EIDCardLibrary/StoredCredentialManagement.h
@EIDCardLibrary/StoredCredentialManagement.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add internal span-based buffer processing functions</name>
  <files>EIDCardLibrary/StoredCredentialManagement.h</files>
  <action>
1. Add `#include <span>` after existing includes (around line 20-30)
2. Add two private internal helper function declarations BEFORE the public StorePrivateData declarations (around line 94):
   ```cpp
   // Internal buffer processing using std::span for bounds safety
   void ProcessSecretBufferInternal(__in DWORD dwRid, std::span<const BYTE> secret) noexcept;
   void ProcessSecretBufferDebugInternal(__in DWORD dwRid, std::span<const BYTE> secret) noexcept;
   ```
3. DO NOT modify existing public StorePrivateData/StorePrivateDataDebug signatures - they must remain C-style for Windows API compatibility

WHY std::span is LSASS-safe: std::span is a non-owning view with no heap allocation - it cannot throw exceptions in basic operations.
  </action>
  <verify>grep -n "ProcessSecretBufferInternal" "C:/Users/user/Documents/EIDAuthentication/EIDCardLibrary/StoredCredentialManagement.h"</verify>
  <done>StoredCredentialManagement.h declares internal span-based helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Implement internal span-based buffer processing functions</name>
  <files>EIDCardLibrary/StoredCredentialManagement.cpp</files>
  <action>
1. Add `#include <span>` after existing includes (around line 20)
2. Implement ProcessSecretBufferInternal before StorePrivateData (around line 1950):
   ```cpp
   void CStoredCredentialManager::ProcessSecretBufferInternal(__in DWORD dwRid, std::span<const BYTE> secret) noexcept
   {
       // Bounds-safe access with automatic size tracking
       if (secret.empty()) {
           EIDCardLibraryTrace(WINEVENT_LEVEL_WARNING, L"ProcessSecretBufferInternal: empty buffer for RID 0x%08X", dwRid);
           return;
       }

       // Example bounds-safe iteration (replace with actual secret processing from existing StorePrivateData)
       for (const auto& byte : secret) {
           // Process each byte safely - buffer.size() automatically available
           UNREFERENCED_PARAMETER(byte);
       }

       // Access size without separate parameter: secret.size()
       DWORD dwSecretSize = static_cast<DWORD>(secret.size());
       EIDCardLibraryTrace(WINEVENT_LEVEL_INFO, L"ProcessSecretBufferInternal: RID 0x%08X, size %u", dwRid, dwSecretSize);
   }
   ```
3. Implement ProcessSecretBufferDebugInternal similarly (around line 2040)
4. DO NOT store std::span in class members - only use as function parameters

NOTE: This creates the pattern for span usage. Actual secret processing logic can be migrated from StorePrivateData in future work.
  </action>
  <verify>grep -n "ProcessSecretBufferInternal\|std::span" "C:/Users/user/Documents/EIDAuthentication/EIDCardLibrary/StoredCredentialManagement.cpp"</verify>
  <done>StoredCredentialManagement.cpp implements internal span-based helper functions</done>
</task>

<task type="auto">
  <name>Task 3: Update exported functions to call internal span-based helpers</name>
  <files>EIDCardLibrary/StoredCredentialManagement.cpp</files>
  <action>
1. Modify StorePrivateData (around line 1961) to call internal span-based helper:
   ```cpp
   BOOL CStoredCredentialManager::StorePrivateData(__in DWORD dwRid, __in_opt PBYTE pbSecret, __in_opt USHORT usSecretSize)
   {
       // Convert C-style buffer to span for internal processing
       if (pbSecret == nullptr && usSecretSize > 0) {
           SetLastError(ERROR_INVALID_PARAMETER);
           return FALSE;
       }

       std::span<const BYTE> secretSpan(pbSecret, usSecretSize);
       ProcessSecretBufferInternal(dwRid, secretSpan);

       return TRUE;
   }
   ```
2. Modify StorePrivateDataDebug similarly (around line 2048)
3. DO NOT change function signatures - exported API must remain C-style
4. The conversion happens at the API boundary, internal code uses span

Pattern: C-style API (exports) -> span conversion -> internal span-based processing
  </action>
  <verify>grep -B2 -A5 "ProcessSecretBufferInternal(dwRid" "C:/Users/user/Documents/EIDAuthentication/EIDCardLibrary/StoredCredentialManagement.cpp"</verify>
  <done>Exported StorePrivateData functions convert to span and call internal helpers</done>
</task>

</tasks>

<verification>
1. Verify StoredCredentialManagement.h has `#include <span>`
2. Verify StoredCredentialManagement.cpp has `#include <span>`
3. Verify internal functions (ProcessSecretBufferInternal) are declared in header
4. Verify internal functions are implemented in cpp
5. Verify exported functions convert to span and call internal helpers
6. Verify NO std::span stored in class members (grep for "span.*m_")
7. Build EIDCardLibrary project - should compile with C++23
</verification>

<success_criteria>
1. std::span used in 2 internal functions for bounds-safe buffer handling
2. Exported API boundaries maintain C-style signatures
3. No std::span stored in class members (lifetime safety maintained)
4. EIDCardLibrary builds successfully with C++23
5. QUAL-04 requirement satisfied: std::span at internal function boundaries
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-quality/04-03-SUMMARY.md`
</output>
