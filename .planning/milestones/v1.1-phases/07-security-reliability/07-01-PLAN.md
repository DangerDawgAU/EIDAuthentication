---
phase: 07-security-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - EIDCardLibrary/StringConversion.cpp
  - EIDConfigurationWizard/DebugReport.cpp
autonomous: true

must_haves:
  truths:
    - "strlen calls are protected against null pointer dereference"
    - "Static buffers used with strlen have compile-time known bounds"
    - "Code compiles without errors after security fixes"
  artifacts:
    - path: "EIDCardLibrary/StringConversion.cpp"
      provides: "Safe string conversion utilities"
      contains: "ConvertCharToWString"
    - path: "EIDConfigurationWizard/DebugReport.cpp"
      provides: "Debug reporting functionality"
      contains: "LSA_STRING Origin"
  key_links:
    - from: "StringConversion.cpp::ConvertCharToWString"
      to: "strlen"
      via: "direct call"
      pattern: "strlen\\(src\\)"
    - from: "DebugReport.cpp::TestLogon"
      to: "strlen"
      via: "LSA_STRING initialization"
      pattern: "strlen\\(s_szMyTest\\)"
---

<objective>
Fix SonarQube security hotspots (cpp:S5813) - strlen safety issues in StringConversion.cpp and DebugReport.cpp.

Purpose: Eliminate potential null pointer dereference and ensure string length calculations are safe.
Output: Modified files with safe string length handling that SonarQube will accept.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Issue Details

### Issue 1: StringConversion.cpp line 166 (Security Hotspot)

**Location:** `EIDCardLibrary/StringConversion.cpp` line 166
**Rule:** cpp:S5813 - strlen should not be called on potentially null pointers
**Current code:**
```cpp
std::wstring ConvertCharToWString(const char* src)
{
    if (!src) {
        return std::wstring();
    }

    size_t len = strlen(src);  // Line 166 - SonarQube flags this
    return SafeConvert(src, len);
}
```

**Analysis:** The null check exists on line 162-164, but SonarQube does not recognize the pattern. The fix is to combine the check and length calculation to make the safety explicit.

**Fix:** Use a pattern SonarQube recognizes, or use `strnlen` with a reasonable max bound.

### Issue 2: DebugReport.cpp line 44 (Security Hotspot)

**Location:** `EIDConfigurationWizard/DebugReport.cpp` line 44
**Rule:** cpp:S5813 - strlen should not be called on potentially null pointers
**Current code:**
```cpp
static char s_szMyTest[] = "MYTEST";  // Line 30 - static buffer
// ...
LSA_STRING Origin = { (USHORT)strlen(s_szMyTest), (USHORT)sizeof(s_szMyTest), s_szMyTest };  // Line 44
```

**Analysis:** The buffer is a static char array with compile-time known content. This is actually safe, but SonarQube flags `strlen` on any pointer. The issue is that `strlen` returns the string length without null terminator, while `sizeof` includes it.

**Fix:** Use `sizeof(s_szMyTest) - 1` directly since the content is known at compile time, or use a constexpr length calculation.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix strlen safety in StringConversion.cpp</name>
  <files>EIDCardLibrary/StringConversion.cpp</files>
  <action>
    In the `ConvertCharToWString` function (around line 160-168):

    Change the current implementation:
    ```cpp
    std::wstring ConvertCharToWString(const char* src)
    {
        if (!src) {
            return std::wstring();
        }

        size_t len = strlen(src);
        return SafeConvert(src, len);
    }
    ```

    To a safer pattern that SonarQube recognizes:
    ```cpp
    std::wstring ConvertCharToWString(const char* src)
    {
        if (!src || src[0] == '\0') {
            return std::wstring();
        }

        // Use strnlen with a reasonable max bound for safety
        // Max path + filename on Windows is ~260 characters, use 4096 as safe upper bound
        size_t len = strnlen(src, 4096);
        return SafeConvert(src, len);
    }
    ```

    This addresses the SonarQube issue by:
    1. Using `strnlen` with a bound, which is inherently safer than unbounded `strlen`
    2. Adding an early exit for empty strings
    3. The 4096 bound is a reasonable upper limit for any string that would be converted
  </action>
  <verify>
    Build EIDCardLibrary project and verify no compiler errors:
    ```
    msbuild EIDCardLibrary/EIDCardLibrary.vcxproj /p:Configuration=Release /p:Platform=x64 /t:Build
    ```
  </verify>
  <done>
    `ConvertCharToWString` uses `strnlen` with bound instead of `strlen`, addressing cpp:S5813.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix strlen safety in DebugReport.cpp</name>
  <files>EIDConfigurationWizard/DebugReport.cpp</files>
  <action>
    In the `TestLogon` function (around line 33-44):

    Change the current LSA_STRING initialization:
    ```cpp
    static char s_szMyTest[] = "MYTEST";
    // ...
    LSA_STRING Origin = { (USHORT)strlen(s_szMyTest), (USHORT)sizeof(s_szMyTest), s_szMyTest };
    ```

    To use compile-time known length:
    ```cpp
    static char s_szMyTest[] = "MYTEST";
    static constexpr size_t s_szMyTestLen = sizeof(s_szMyTest) - 1;  // Length without null terminator
    // ...
    LSA_STRING Origin = { (USHORT)s_szMyTestLen, (USHORT)sizeof(s_szMyTest), s_szMyTest };
    ```

    This eliminates the `strlen` call entirely by computing the length at compile time.
    The `constexpr` variable is computed during compilation, so there is no runtime overhead.
  </action>
  <verify>
    Build EIDConfigurationWizard project and verify no compiler errors:
    ```
    msbuild EIDConfigurationWizard/EIDConfigurationWizard.vcxproj /p:Configuration=Release /p:Platform=x64 /t:Build
    ```
  </verify>
  <done>
    LSA_STRING initialization uses compile-time constant instead of `strlen`, addressing cpp:S5813.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build the full solution:
   ```
   msbuild EIDAuthentication.sln /p:Configuration=Release /p:Platform=x64 /t:Build
   ```

2. Verify no new compiler warnings introduced.

3. Mark SonarQube security hotspots as resolved:
   - StringConversion.cpp line 166: Fixed by using strnlen with bound
   - DebugReport.cpp line 44: Fixed by using compile-time constant
</verification>

<success_criteria>
1. StringConversion.cpp uses `strnlen` with bound instead of unbounded `strlen`
2. DebugReport.cpp uses compile-time constant instead of `strlen` on static buffer
3. Both files compile without errors
4. No new compiler warnings introduced
5. SonarQube security hotspots cpp:S5813 can be marked as resolved
</success_criteria>

<output>
After completion, create `.planning/phases/07-security-reliability/07-01-SUMMARY.md`
</output>
