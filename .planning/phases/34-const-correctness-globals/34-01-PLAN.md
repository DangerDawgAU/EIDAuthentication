---
phase: 34-const-correctness-globals
plan: 01
type: execute
wave: 1
depends_on: [31-01]
files_modified: []
autonomous: true
requirements: [CONST-01, CONST-02]

must_haves:
  truths:
    - "All global variables analyzed for const eligibility"
    - "Runtime-assigned globals documented as won't-fix with justification"
    - "Set*() pattern and DllMain initialization checked before marking const"
    - "Build passes with zero errors after analysis"
  artifacts:
    - path: ".planning/phases/34-const-correctness-globals/34-01-SUMMARY.md"
      provides: "Complete analysis of global variables with const status"
  key_links:
    - from: "Phase 31 (Macro to constexpr)"
      to: "Phase 34 (Const Correctness - Globals)"
      via: "Macro conversion enables some globals to reference constexpr values"
      pattern: "Phase 31 must complete before global const analysis"
---

<objective>
Analyze all global variables in the codebase to determine const eligibility, mark truly immutable globals as const, and document runtime-assigned globals as won't-fix.

Purpose: Achieve const correctness for global variables while recognizing that most globals in this LSA authentication package are runtime-initialized and cannot be const.

Output: Complete analysis document (SUMMARY.md) categorizing each global as const-eligible or won't-fix with justification.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Previous phase context
Phase 31 (Macro to constexpr) converts simple value macros to constexpr, which may enable some globals to reference constexpr values. However, most globals in this codebase are runtime-assigned.

# Codebase Analysis Results

## Global Variables Found

### EIDCardLibrary/Package.cpp
- `MyAllocateHeap`, `MyFreeHeap`, `MyImpersonate` - Set via SetAlloc/SetFree/SetImpersonate functions - **WON'T FIX**
- `TraceAllocation` - Already const `const BOOL TraceAllocation = TRUE;`

### EIDCardLibrary/Tracing.cpp
- `bFirst` - Modified during EIDCardLibraryTracingRegister() - **WON'T FIX**
- `g_csTraceInitialized` - Modified during initialization - **WON'T FIX**
- `IsTracingEnabled` - Modified via EnableCallback - **WON'T FIX**
- `hPub`, `Section`, `g_csTrace` - Modified during registration - **WON'T FIX**

### EIDCardLibrary/TraceExport.cpp
- `g_hTraceOutputFile` - Modified at runtime in ExportOneTraceFile - **WON'T FIX**

### EIDCardLibrary/StoredCredentialManagement.cpp
- `samsrvDll`, function pointers (MySamrConnect, etc.) - Loaded at runtime via LoadSamSrv() - **WON'T FIX**

### EIDCredentialProvider/Dll.cpp
- `g_cRef` - Modified via InterlockedIncrement/Decrement - **WON'T FIX**
- `g_hinst` - Assigned in DllMain - **WON'T FIX**

### EIDLogManager/EIDLogManager.cpp
- `hFile` - Modified at runtime - **WON'T FIX**

### EIDConfigurationWizard/EIDConfigurationWizard.cpp
- `fShowNewCertificatePanel`, `fGotoNewScreen` - Modified at runtime - **WON'T FIX**
- `g_hinst` - Assigned in WinMain - **WON'T FIX**
- `szReader`, `szCard`, `szUserName`, `szPassword` - Modified at runtime - **WON'T FIX**
- `dwReaderSize`, `dwCardSize`, `dwUserNameSize`, `dwPasswordSize` - Already const

### EIDConfigurationWizard/DebugReport.cpp
- `hInternalLogWriteHandle` - Modified at runtime - **WON'T FIX**

### EIDConfigurationWizard/EIDConfigurationWizardPage03.cpp
- `pRootCertificate` - Modified at runtime - **WON'T FIX**
- `DEFAULT_CERT_VALIDITY_YEARS`, `MAX_CERT_VALIDITY_YEARS`, `MIN_CERT_VALIDITY_YEARS` - Already constexpr

### EIDConfigurationWizard/EIDConfigurationWizardPage04.cpp
- `pCredentialList`, `dwCurrentCredential`, `fHasDeselected` - Modified at runtime - **WON'T FIX**

### EIDConfigurationWizard/EIDConfigurationWizardPage05.cpp
- `dwWizardError`, `hwndInvalidPasswordBalloon` - Modified at runtime - **WON'T FIX**
- `WM_MYMESSAGE` - Already constexpr
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify no const-eligible globals remain</name>
  <files>(analysis only, no file changes expected)</files>
  <action>
Re-scan the codebase to verify that all global variables have been properly analyzed. Check specifically for:

1. Globals with compile-time constant initializers that are never modified
2. Globals that could reference constexpr values from Phase 31
3. Any new globals added since the initial scan

For each file, verify:
- Package.cpp: MyAllocateHeap etc. have Set*() functions - cannot be const
- Tracing.cpp: All globals modified during registration/callbacks
- Dll.cpp: g_cRef is reference counted, g_hinst assigned in DllMain
- All wizard files: Globals are UI state modified at runtime

If any truly immutable global is found (initialized at compile-time, never modified), add `const` qualifier.
</action>
  <verify>grep -r "^[A-Za-z_].*\s*g_[A-Za-z].*=.*;" --include="*.cpp" should show no new const-eligible patterns</verify>
  <done>Analysis confirms all globals are either already const, or documented as won't-fix</done>
</task>

<task type="auto">
  <name>Task 2: Create won't-fix documentation</name>
  <files>.planning/phases/34-const-correctness-globals/34-01-SUMMARY.md</files>
  <action>
Create a comprehensive SUMMARY.md documenting the analysis results with the following structure:

## Global Variable Const Analysis

### Summary
- Total globals analyzed: ~25
- Already const/constexpr: 8
- Won't-fix (runtime-assigned): ~17
- Marked const this phase: 0

### Already Const/constexpr
List each already-const global with file location and value.

### Won't Fix Categories

#### 1. LSA Function Pointers (Package.cpp)
- `MyAllocateHeap`, `MyFreeHeap`, `MyImpersonate`
- **Justification**: Assigned via SetAlloc/SetFree/SetImpersonate functions called by LSA during initialization. These are LSA-provided function pointers required for memory allocation in LSASS context.

#### 2. Tracing State (Tracing.cpp)
- `bFirst`, `g_csTraceInitialized`, `IsTracingEnabled`, `hPub`, `Section`
- **Justification**: ETW tracing state modified during registration and by enable/disable callbacks. ETW EnableCallback can be called from any thread.

#### 3. DLL State (Dll.cpp)
- `g_cRef`, `g_hinst`
- **Justification**: g_cRef is reference count modified via InterlockedIncrement/Decrement for DLL lifecycle. g_hinst is assigned in DllMain on DLL_PROCESS_ATTACH.

#### 4. SAM Function Pointers (StoredCredentialManagement.cpp)
- `samsrvDll`, `MySamrConnect`, etc.
- **Justification**: Loaded dynamically at runtime via LoadSamSrv() using GetProcAddress. SAM API functions cannot be resolved at compile time.

#### 5. UI State (EIDConfigurationWizard/*.cpp)
- Various globals like `pCredentialList`, `dwCurrentCredential`, `fHasDeselected`, `pRootCertificate`, etc.
- **Justification**: Windows UI state modified during wizard operation. These are inherently runtime state.

#### 6. File Handles
- `hFile`, `hInternalLogWriteHandle`, `g_hTraceOutputFile`
- **Justification**: File handles opened/closed at runtime for logging operations.

### No Changes Required
All globals in this codebase are either already const/constexpr or are runtime-assigned and cannot be made const. The codebase correctly uses runtime initialization for LSA integration and UI state management.
</action>
  <verify>cat .planning/phases/34-const-correctness-globals/34-01-SUMMARY.md contains all won't-fix categories with justifications</verify>
  <done>SUMMARY.md documents complete analysis with justifications for all won't-fix globals</done>
</task>

<task type="auto">
  <name>Task 3: Build verification</name>
  <files>(no source changes)</files>
  <action>
Run build verification to confirm no changes were made that could break compilation.

Since this phase is analysis-only (no const additions possible), the build should pass unchanged.

Run: msbuild EIDAuthentication.sln /p:Configuration=Release /p:Platform=x64 /t:Build /v:m

Verify zero errors and no new warnings.
</action>
  <verify>Build completes with 0 errors, 0 new warnings</verify>
  <done>Build verification confirms codebase stability</done>
</task>

</tasks>

<verification>
1. SUMMARY.md exists with complete analysis
2. All globals categorized as already-const or won't-fix
3. Won't-fix categories have specific justifications
4. Build passes with zero errors
</verification>

<success_criteria>
1. All global variables in the codebase analyzed for const eligibility
2. Compile-time constant globals marked const (none found - all are runtime-assigned)
3. Runtime-assigned globals documented as won't-fix with specific justifications
4. Set*() pattern and DllMain initialization verified before marking const
5. Build passes with zero errors after analysis
</success_criteria>

<output>
After completion, create `.planning/phases/34-const-correctness-globals/34-01-SUMMARY.md` documenting:
- Complete list of analyzed globals
- Already const/constexpr globals
- Won't-fix globals with justification categories
- Conclusion that no const additions are possible in this phase
</output>
