---
phase: 02-error-handling
plan: 03
type: execute
wave: 3
depends_on: [02-01, 02-02]
files_modified:
  - EIDCardLibrary/CertificateValidation.cpp
  - EIDCardLibrary/CertificateUtilities.cpp
  - EIDCardLibrary/CompleteToken.cpp
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Internal functions return EID::Result<T> instead of BOOL"
    - "Exported functions maintain C-style signatures (HRESULT, BOOL)"
    - "API boundary conversions use EID::to_bool() for HRESULT/BOOL translation"
    - "Error codes propagate correctly through conversion layer"
    - "LSA functions use EID::hr_to_ntstatus() for NTSTATUS conversion"
  artifacts:
    - path: "EIDCardLibrary/CertificateValidation.cpp"
      provides: "HasCertificateRightEKUInternal() returning ResultVoid"
      exports: ["HasCertificateRightEKUInternal"]
      contains: "EID::ResultVoid|return EID::make_unexpected"
    - path: "EIDCardLibrary/CertificateUtilities.cpp"
      provides: "Internal certificate functions returning Result<T>"
      exports: ["GetCertificateFromCspInfoInternal", "ValidateCertificateInternal"]
      contains: "EID::Result|return EID::make_unexpected"
    - path: "EIDCardLibrary/CompleteToken.cpp"
      provides: "UserNameToToken() with NTSTATUS conversion at boundary"
      exports: ["UserNameToToken"]
      contains: "EID::hr_to_ntstatus"
  key_links:
    - from: "CertificateValidation.cpp (HasCertificateRightEKUInternal)"
      to: "Exported HasCertificateRightEKU()"
      via: "EID::to_bool() conversion wrapper"
      pattern: "return EID::to_bool\\(HasCertificateRightEKUInternal"
    - from: "CompleteToken.cpp (UserNameToToken)"
      to: "NTSTATUS return type"
      via: "EID::hr_to_ntstatus() for HRESULT to NTSTATUS mapping"
      pattern: "EID::hr_to_ntstatus\\(.*\\.error\\(\\)"
    - from: "Internal functions"
      to: "EIDCardLibrary/ErrorHandling.h"
      via: "Using EID::Result<T>, EID::make_unexpected()"
      pattern: "#include \"ErrorHandling.h\""
---

<objective>
Create API boundary conversion layer that preserves C-style exported function signatures (HRESULT, BOOL, NTSTATUS) while internal functions use EID::Result<T> for type-safe error handling.

Purpose: Exported LSA/Credential Provider functions must maintain C-style signatures for binary compatibility with Windows. Internal functions can use modern std::expected pattern. This plan creates conversion wrappers at API boundaries that translate between EID::Result<T> and HRESULT/BOOL/NTSTATUS using the helpers from 02-02.

Output: Migrated internal functions to Result<T> with exported boundary wrappers maintaining original signatures.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling/02-RESEARCH.md
@.planning/phases/02-error-handling/02-01-SUMMARY.md
@.planning/phases/02-error-handling/02-02-SUMMARY.md
@.planning/phases/01-build-system/01-03-SUMMARY.md

# Locked decisions from STATE.md
- "C-style APIs: Preserve HRESULT/BOOL at exported boundaries"
- "LSASS context: No exceptions, no console I/O, static CRT required"

# Research patterns to apply
From 02-RESEARCH.md Pattern 2 (API Boundary Conversion - HRESULT):
```cpp
[[nodiscard]] EID::Result<PCCERT_CONTEXT> GetCertificateFromCspInfoInternal(
    PEID_SMARTCARD_CSP_INFO pCspInfo) noexcept;

HRESULT GetCertificateFromCspInfo(
    __in PEID_SMARTCARD_CSP_INFO pCspInfo,
    __out PCCERT_CONTEXT* ppCertContext)
{
    if (ppCertContext == nullptr) {
        return E_POINTER;
    }
    auto result = GetCertificateFromCspInfoInternal(pCspInfo);
    if (result) {
        *ppCertContext = *result;
        return S_OK;
    }
    return result.error();
}
```

From 02-RESEARCH.md Pattern 3 (API Boundary Conversion - BOOL):
```cpp
[[nodiscard]] EID::Result<void> DoSomethingInternal() noexcept;

BOOL DoSomething() noexcept
{
    auto result = DoSomethingInternal();
    if (result) {
        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }
    SetLastError(static_cast<DWORD>(result.error()));
    return FALSE;
}
```

From 02-RESEARCH.md Pattern 4 (API Boundary Conversion - NTSTATUS):
```cpp
[[nodiscard]] EID::Result<void> CheckAuthorizationInternal(
    PWSTR UserName,
    NTSTATUS* SubStatus,
    LARGE_INTEGER* ExpirationTime) noexcept;

NTSTATUS CheckAuthorization(
    PWSTR UserName,
    NTSTATUS* SubStatus,
    LARGE_INTEGER* ExpirationTime)
{
    auto result = CheckAuthorizationInternal(UserName, SubStatus, ExpirationTime);
    if (result) {
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor HasCertificateRightEKU to Result<T> pattern</name>
  <files>EIDCardLibrary/CertificateValidation.cpp</files>
  <action>
Refactor HasCertificateRightEKU() in CertificateValidation.cpp to use internal Result<T> function with exported BOOL wrapper.

Current signature (preserved):
```cpp
BOOL HasCertificateRightEKU(__in PCCERT_CONTEXT pCertContext)
```

Steps:
1. Add #include "ErrorHandling.h" if not already present (via EIDCardLibrary.h)

2. Create internal function (before exported HasCertificateRightEKU):
```cpp
[[nodiscard]] EID::ResultVoid HasCertificateRightEKUInternal(
    __in PCCERT_CONTEXT pCertContext) noexcept
{
    // Move existing HasCertificateRightEKU implementation here
    // Replace __leave with return EID::make_unexpected(HRESULT_FROM_WIN32(dwError))
    // Replace "return TRUE" at end with "return {};" (success for ResultVoid)
    // Replace SetLastError(dwError) + return FALSE with return EID::make_unexpected(...)

    // Example conversion:
    // OLD: if (!SomeApi()) { dwError = GetLastError(); __leave; }
    // NEW: if (!SomeApi()) { return EID::make_unexpected(HRESULT_FROM_WIN32(GetLastError())); }
}
```

3. Replace exported HasCertificateRightEKU with thin wrapper:
```cpp
BOOL HasCertificateRightEKU(__in PCCERT_CONTEXT pCertContext) noexcept
{
    return EID::to_bool(HasCertificateRightEKUInternal(pCertContext));
}
```

Key conversions:
- SetLastError(dwError); return FALSE; -> return EID::make_unexpected(HRESULT_FROM_WIN32(dwError))
- return TRUE; -> return {};
- Remove __try/__finally blocks (RAII cleanup preferred, but keep if __finally has cleanup logic)
  </action>
  <verify>
Build EIDCardLibrary and verify HasCertificateRightEKU links correctly
Test that BOOL return values match original behavior (TRUE on success, FALSE with SetLastError on error)
  </verify>
  <done>HasCertificateRightEKUInternal returns ResultVoid, exported HasCertificateRightEKU uses to_bool()</done>
</task>

<task type="auto">
  <name>Task 2: Refactor ValidateCertificate to Result<T> pattern</name>
  <files>EIDCardLibrary/CertificateValidation.cpp</files>
  <action>
Refactor ValidateCertificate() in CertificateValidation.cpp to use internal Result<T> function with exported HRESULT wrapper.

Current signature (preserved):
```cpp
HRESULT ValidateCertificate(__in PCCERT_CONTEXT pCertContext)
```

Steps:
1. Create internal function:
```cpp
[[nodiscard]] EID::ResultVoid ValidateCertificateInternal(
    __in PCCERT_CONTEXT pCertContext) noexcept
{
    // Move existing ValidateCertificate implementation here
    // Convert HRESULT error returns to EID::make_unexpected(hr)
    // Convert S_OK return to "return {};"
}
```

2. Replace exported ValidateCertificate with thin wrapper:
```cpp
HRESULT ValidateCertificate(__in PCCERT_CONTEXT pCertContext) noexcept
{
    auto result = ValidateCertificateInternal(pCertContext);
    if (result) {
        return S_OK;
    }
    return result.error();
}
```

Key conversions:
- return hrError; -> return EID::make_unexpected(hrError)
- return S_OK; -> return {};
- Keep all validation logic (chain verification, EKU checking, time validity)
  </action>
  <verify>
Build EIDCardLibrary and verify ValidateCertificate links correctly
Test that HRESULT return values match original behavior
  </verify>
  <done>ValidateCertificateInternal returns ResultVoid, exported ValidateCertificate extracts HRESULT</done>
</task>

<task type="auto">
  <name>Task 3: Refactor UserNameToToken with NTSTATUS conversion</name>
  <files>EIDCardLibrary/CompleteToken.cpp</files>
  <action>
Refactor UserNameToToken() in CompleteToken.cpp to use internal Result<T> with NTSTATUS boundary conversion.

Current signature (preserved):
```cpp
NTSTATUS UserNameToToken(
    __in PLSA_UNICODE_STRING AccountName,
    __out PLSA_TOKEN_INFORMATION_V2 *Token,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus)
```

Steps:
1. Add #include "ErrorHandling.h" if not present

2. Create internal function returning Result<PLSA_TOKEN_INFORMATION_V2>:
```cpp
[[nodiscard]] EID::Result<PLSA_TOKEN_INFORMATION_V2> UserNameToTokenInternal(
    __in PLSA_UNICODE_STRING AccountName,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus) noexcept
{
    // Move existing UserNameToToken implementation here
    // Convert "Status = STATUS_*; __leave;" to "return EID::make_unexpected(HRESULT_FROM_NT(Status))"
    // Convert "*Token = ...; return STATUS_SUCCESS;" to "*TokenLength = ...; return value;"

    // Note: Need HRESULT_FROM_NT macro or mapping for NTSTATUS -> HRESULT
    // For now, convert NTSTATUS to HRESULT via: return EID::make_unexpected(static_cast<HRESULT>(Status))
}
```

3. Replace exported UserNameToToken with wrapper:
```cpp
NTSTATUS UserNameToToken(
    __in PLSA_UNICODE_STRING AccountName,
    __out PLSA_TOKEN_INFORMATION_V2 *Token,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus)
{
    auto result = UserNameToTokenInternal(AccountName, TokenLength, SubStatus);
    if (result) {
        *Token = *result;
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```

Note: CompleteToken.cpp may need HRESULT_FROM_NT macro if not defined. Add if needed:
```cpp
#define HRESULT_FROM_NT(x) ((HRESULT) ((x) | FACILITY_NT_BIT))
```
  </action>
  <verify>
Build EIDCardLibrary and verify UserNameToToken links correctly
Test that NTSTATUS return values match original behavior
  </verify>
  <done>UserNameToTokenInternal returns Result<PLSA_TOKEN_INFORMATION_V2>, exported UserNameToToken uses hr_to_ntstatus()</done>
</task>

<task type="auto">
  <name>Task 4: Refactor CheckAuthorization with NTSTATUS conversion</name>
  <files>EIDCardLibrary/CompleteToken.cpp</files>
  <action>
Refactor CheckAuthorization() in CompleteToken.cpp to use internal Result<T> with NTSTATUS boundary conversion.

Current signature (preserved):
```cpp
NTSTATUS CheckAuthorization(PWSTR UserName, NTSTATUS *SubStatus, LARGE_INTEGER *ExpirationTime)
```

Steps:
1. Create internal function:
```cpp
[[nodiscard]] EID::Result<LARGE_INTEGER> CheckAuthorizationInternal(
    PWSTR UserName,
    NTSTATUS* SubStatus) noexcept
{
    // Move existing CheckAuthorization implementation here
    // Return ExpirationTime on success
    // Convert "return Status" errors to "return EID::make_unexpected(HRESULT_FROM_NT(Status))"
}
```

2. Replace exported CheckAuthorization with wrapper:
```cpp
NTSTATUS CheckAuthorization(PWSTR UserName, NTSTATUS *SubStatus, LARGE_INTEGER *ExpirationTime)
{
    auto result = CheckAuthorizationInternal(UserName, SubStatus);
    if (result) {
        *ExpirationTime = *result;
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```

Note: CheckAuthorization likely calls NameToSid, GetGroups, etc. Those remain BOOL functions for now (future phases may migrate them).
  </action>
  <verify>
Build EIDCardLibrary and verify CheckAuthorization links correctly
Test that NTSTATUS return values and ExpirationTime output match original behavior
  </verify>
  <done>CheckAuthorizationInternal returns Result<LARGE_INTEGER>, exported CheckAuthorization uses hr_to_ntstatus()</done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 5: Verify API boundary conversion layer</name>
  <what-built>Complete API boundary conversion layer with internal Result<T> functions and exported C-style wrappers</what-built>
  <how-to-verify>
1. Build EIDCardLibrary project (all configurations: Debug|Release x Win32|x64)
2. Verify zero compile errors and zero warnings
3. Inspect exported functions using dumpbin /EXPORTS:
   ```
   dumpbin /EXPORTS EIDCardLibrary.lib
   ```
   Verify exported signatures match original (HRESULT, BOOL, NTSTATUS - no std::expected in exports)
4. Test call chains:
   - Call HasCertificateRightEKU with valid cert -> returns TRUE
   - Call HasCertificateRightEKU with invalid cert -> returns FALSE, check GetLastError() for error code
   - Call ValidateCertificate with valid cert -> returns S_OK
   - Call ValidateCertificate with invalid cert -> returns error HRESULT
5. Verify error propagation:
   - Internal errors correctly convert to HRESULT at boundary
   - NTSTATUS functions correctly map HRESULT errors via hr_to_ntstatus()
  </how-to-verify>
  <resume-signal>Type "approved" to continue or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. All exported function signatures unchanged (HRESULT, BOOL, NTSTATUS)
2. Internal functions use EID::Result<T> with [[nodiscard]] and noexcept
3. Boundary conversions use EID::to_bool() for BOOL wrappers
4. Boundary conversions use EID::hr_to_ntstatus() for NTSTATUS wrappers
5. Error codes propagate correctly through conversion layer
6. No exceptions thrown in LSASS context (all noexcept)
</verification>

<success_criteria>
1. HasCertificateRightEKU, ValidateCertificate migrated to Result<T> pattern
2. UserNameToToken, CheckAuthorization migrated to Result<T> pattern with NTSTATUS conversion
3. All exported functions maintain C-style signatures
4. Zero compile errors across all configurations
5. Error propagation verified correct (GetLastError, HRESULT, NTSTATUS all set correctly)
6. Ready for Phase 3 (Compile-Time Enhancements)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-03-SUMMARY.md`
</output>
