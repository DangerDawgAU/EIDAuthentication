---
phase: 02-error-handling
plan: 03
type: execute
wave: 3
depends_on: [02-01a, 02-01b, 02-02]
files_modified:
  - EIDCardLibrary/CertificateValidation.cpp
  - EIDCardLibrary/CertificateUtilities.cpp
  - EIDCardLibrary/CompleteToken.cpp
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Internal functions return EID::Result<T> instead of BOOL"
    - "Exported functions maintain C-style signatures (HRESULT, BOOL)"
    - "API boundary conversions use EID::to_bool() for HRESULT/BOOL translation"
    - "Error codes propagate correctly through conversion layer"
    - "LSA functions use EID::hr_to_ntstatus() for NTSTATUS conversion"
    - "All new error-handling code marked noexcept (LSASS compatibility)"
  artifacts:
    - path: "EIDCardLibrary/CertificateValidation.cpp"
      provides: "HasCertificateRightEKUInternal() returning ResultVoid"
      exports: ["HasCertificateRightEKUInternal"]
      contains: "EID::ResultVoid|return EID::make_unexpected"
    - path: "EIDCardLibrary/CertificateValidation.cpp"
      provides: "ValidateCertificateInternal() returning ResultVoid"
      exports: ["ValidateCertificateInternal"]
      contains: "EID::ResultVoid|return EID::make_unexpected"
    - path: "EIDCardLibrary/CertificateUtilities.cpp"
      provides: "Internal certificate functions returning Result<T>"
      exports: ["GetCertificateFromCspInfoInternal", "ValidateCertificateInternal"]
      contains: "EID::Result|return EID::make_unexpected"
    - path: "EIDCardLibrary/CertificateUtilities.cpp"
      provides: "GetCertificateFromCspInfo refactored to Result<T> pattern"
      exports: ["GetCertificateFromCspInfoInternal"]
      contains: "EID::Result.*GetCertificateFromCspInfoInternal.*noexcept"
    - path: "EIDCardLibrary/CompleteToken.cpp"
      provides: "UserNameToToken() with NTSTATUS conversion at boundary"
      exports: ["UserNameToToken"]
      contains: "EID::hr_to_ntstatus"
    - path: "EIDCardLibrary/CompleteToken.cpp"
      provides: "CheckAuthorizationInternal() returning Result<T>"
      exports: ["CheckAuthorizationInternal"]
      contains: "EID::Result.*CheckAuthorizationInternal.*noexcept"
  key_links:
    - from: "CertificateValidation.cpp (HasCertificateRightEKUInternal)"
      to: "Exported HasCertificateRightEKU()"
      via: "EID::to_bool() conversion wrapper"
      pattern: "return EID::to_bool\\(HasCertificateRightEKUInternal"
    - from: "CertificateUtilities.cpp (GetCertificateFromCspInfoInternal)"
      to: "Exported GetCertificateFromCspInfo()"
      via: "Result<T> to HRESULT conversion wrapper"
      pattern: "auto result = GetCertificateFromCspInfoInternal"
    - from: "CompleteToken.cpp (UserNameToToken)"
      to: "NTSTATUS return type"
      via: "EID::hr_to_ntstatus() for HRESULT to NTSTATUS mapping"
      pattern: "EID::hr_to_ntstatus\\(.*\\.error\\(\\)"
    - from: "Internal functions"
      to: "EIDCardLibrary/ErrorHandling.h"
      via: "Using EID::Result<T>, EID::make_unexpected()"
      pattern: "#include \"ErrorHandling.h\""
---

<objective>
Create API boundary conversion layer that preserves C-style exported function signatures (HRESULT, BOOL, NTSTATUS) while internal functions use EID::Result<T> for type-safe error handling.

Purpose: Exported LSA/Credential Provider functions must maintain C-style signatures for binary compatibility with Windows. Internal functions can use modern std::expected pattern. This plan creates conversion wrappers at API boundaries that translate between EID::Result<T> and HRESULT/BOOL/NTSTATUS using the helpers from 02-02.

Output: Migrated internal functions to Result<T> with exported boundary wrappers maintaining original signatures.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling/02-RESEARCH.md
@.planning/phases/02-error-handling/02-01a-SUMMARY.md
@.planning/phases/02-error-handling/02-01b-SUMMARY.md
@.planning/phases/02-error-handling/02-02-SUMMARY.md
@.planning/phases/01-build-system/01-03-SUMMARY.md

# Locked decisions from STATE.md
- "C-style APIs: Preserve HRESULT/BOOL at exported boundaries"
- "LSASS context: No exceptions, no console I/O, static CRT required"

# Research patterns to apply
From 02-RESEARCH.md Pattern 2 (API Boundary Conversion - HRESULT):
```cpp
[[nodiscard]] EID::Result<PCCERT_CONTEXT> GetCertificateFromCspInfoInternal(
    PEID_SMARTCARD_CSP_INFO pCspInfo) noexcept;

HRESULT GetCertificateFromCspInfo(
    __in PEID_SMARTCARD_CSP_INFO pCspInfo,
    __out PCCERT_CONTEXT* ppCertContext)
{
    if (ppCertContext == nullptr) {
        return E_POINTER;
    }
    auto result = GetCertificateFromCspInfoInternal(pCspInfo);
    if (result) {
        *ppCertContext = *result;
        return S_OK;
    }
    return result.error();
}
```

From 02-RESEARCH.md Pattern 3 (API Boundary Conversion - BOOL):
```cpp
[[nodiscard]] EID::Result<void> DoSomethingInternal() noexcept;

BOOL DoSomething() noexcept
{
    auto result = DoSomethingInternal();
    if (result) {
        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }
    SetLastError(static_cast<DWORD>(result.error()));
    return FALSE;
}
```

From 02-RESEARCH.md Pattern 4 (API Boundary Conversion - NTSTATUS):
```cpp
[[nodiscard]] EID::Result<void> CheckAuthorizationInternal(
    PWSTR UserName,
    NTSTATUS* SubStatus,
    LARGE_INTEGER* ExpirationTime) noexcept;

NTSTATUS CheckAuthorization(
    PWSTR UserName,
    NTSTATUS* SubStatus,
    LARGE_INTEGER* ExpirationTime)
{
    auto result = CheckAuthorizationInternal(UserName, SubStatus, ExpirationTime);
    if (result) {
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor HasCertificateRightEKU to Result<T> pattern</name>
  <files>EIDCardLibrary/CertificateValidation.cpp</files>
  <action>
Refactor HasCertificateRightEKU() in CertificateValidation.cpp to use internal Result<T> function with exported BOOL wrapper.

Current signature (preserved):
```cpp
BOOL HasCertificateRightEKU(__in PCCERT_CONTEXT pCertContext)
```

Steps:
1. Add #include "ErrorHandling.h" if not already present (via EIDCardLibrary.h)

2. Create internal function (before exported HasCertificateRightEKU):
```cpp
[[nodiscard]] EID::ResultVoid HasCertificateRightEKUInternal(
    __in PCCERT_CONTEXT pCertContext) noexcept
{
    // Move existing HasCertificateRightEKU implementation here
    // Replace __leave with return EID::make_unexpected(HRESULT_FROM_WIN32(dwError))
    // Replace "return TRUE" at end with "return {};" (success for ResultVoid)
    // Replace SetLastError(dwError) + return FALSE with return EID::make_unexpected(...)

    // Example conversion:
    // OLD: if (!SomeApi()) { dwError = GetLastError(); __leave; }
    // NEW: if (!SomeApi()) { return EID::make_unexpected(HRESULT_FROM_WIN32(GetLastError())); }
}
```

3. Replace exported HasCertificateRightEKU with thin wrapper:
```cpp
BOOL HasCertificateRightEKU(__in PCCERT_CONTEXT pCertContext) noexcept
{
    return EID::to_bool(HasCertificateRightEKUInternal(pCertContext));
}
```

Key conversions:
- SetLastError(dwError); return FALSE; -> return EID::make_unexpected(HRESULT_FROM_WIN32(dwError))
- return TRUE; -> return {};
- Remove __try/__finally blocks (RAII cleanup preferred, but keep if __finally has cleanup logic)

CRITICAL: Mark HasCertificateRightEKUInternal with noexcept (LSASS compatibility requirement)
  </action>
  <verify>
Build EIDCardLibrary and verify HasCertificateRightEKU links correctly
Test that BOOL return values match original behavior (TRUE on success, FALSE with SetLastError on error)
Verify with grep: "HasCertificateRightEKUInternal.*noexcept" confirms noexcept marker present
  </verify>
  <done>HasCertificateRightEKUInternal returns ResultVoid with noexcept, exported HasCertificateRightEKU uses to_bool()</done>
</task>

<task type="auto">
  <name>Task 2: Refactor ValidateCertificate to Result<T> pattern</name>
  <files>EIDCardLibrary/CertificateValidation.cpp</files>
  <action>
Refactor ValidateCertificate() in CertificateValidation.cpp to use internal Result<T> function with exported HRESULT wrapper.

Current signature (preserved):
```cpp
HRESULT ValidateCertificate(__in PCCERT_CONTEXT pCertContext)
```

Steps:
1. Create internal function:
```cpp
[[nodiscard]] EID::ResultVoid ValidateCertificateInternal(
    __in PCCERT_CONTEXT pCertContext) noexcept
{
    // Move existing ValidateCertificate implementation here
    // Convert HRESULT error returns to EID::make_unexpected(hr)
    // Convert S_OK return to "return {};"
}
```

2. Replace exported ValidateCertificate with thin wrapper:
```cpp
HRESULT ValidateCertificate(__in PCCERT_CONTEXT pCertContext) noexcept
{
    auto result = ValidateCertificateInternal(pCertContext);
    if (result) {
        return S_OK;
    }
    return result.error();
}
```

Key conversions:
- return hrError; -> return EID::make_unexpected(hrError)
- return S_OK; -> return {};
- Keep all validation logic (chain verification, EKU checking, time validity)

CRITICAL: Mark ValidateCertificateInternal with noexcept (LSASS compatibility requirement)
  </action>
  <verify>
Build EIDCardLibrary and verify ValidateCertificate links correctly
Test that HRESULT return values match original behavior
Verify with grep: "ValidateCertificateInternal.*noexcept" confirms noexcept marker present
  </verify>
  <done>ValidateCertificateInternal returns ResultVoid with noexcept, exported ValidateCertificate extracts HRESULT</done>
</task>

<task type="auto">
  <name>Task 3: Refactor GetCertificateFromCspInfo to Result<T> pattern</name>
  <files>EIDCardLibrary/CertificateUtilities.cpp</files>
  <action>
Refactor GetCertificateFromCspInfo() in CertificateUtilities.cpp to use internal Result<T> function with exported HRESULT wrapper.

Current signature (preserved):
```cpp
HRESULT GetCertificateFromCspInfo(
    __in PEID_SMARTCARD_CSP_INFO pCspInfo,
    __out PCCERT_CONTEXT* ppCertContext)
```

Steps:
1. Create internal function:
```cpp
[[nodiscard]] EID::Result<PCCERT_CONTEXT> GetCertificateFromCspInfoInternal(
    __in PEID_SMARTCARD_CSP_INFO pCspInfo) noexcept
{
    // Move existing GetCertificateFromCspInfo implementation here
    // Convert error returns to EID::make_unexpected(hr)
    // Convert "*ppCertContext = pCertContext; return S_OK;" to "return pCertContext;"
}
```

2. Replace exported GetCertificateFromCspInfo with wrapper:
```cpp
HRESULT GetCertificateFromCspInfo(
    __in PEID_SMARTCARD_CSP_INFO pCspInfo,
    __out PCCERT_CONTEXT* ppCertContext) noexcept
{
    if (ppCertContext == nullptr) {
        return E_POINTER;
    }
    auto result = GetCertificateFromCspInfoInternal(pCspInfo);
    if (result) {
        *ppCertContext = *result;
        return S_OK;
    }
    return result.error();
}
```

Key conversions:
- SetLastError(hr); return hr; -> return EID::make_unexpected(hr)
- *ppCertContext = pCertContext; return S_OK; -> return pCertContext;
- Keep all certificate extraction logic (CSP parsing, cert store lookup)

CRITICAL: Mark GetCertificateFromCspInfoInternal with noexcept (LSASS compatibility requirement)
  </action>
  <verify>
Build EIDCardLibrary and verify GetCertificateFromCspInfo links correctly
Test that HRESULT return values and ppCertContext output match original behavior
Verify with grep: "GetCertificateFromCspInfoInternal.*noexcept" confirms noexcept marker present
  </verify>
  <done>GetCertificateFromCspInfoInternal returns Result<PCCERT_CONTEXT> with noexcept, exported GetCertificateFromCspInfo extracts HRESULT</done>
</task>

<task type="auto">
  <name>Task 4: Refactor UserNameToToken with NTSTATUS conversion</name>
  <files>EIDCardLibrary/CompleteToken.cpp</files>
  <action>
Refactor UserNameToToken() in CompleteToken.cpp to use internal Result<T> with NTSTATUS boundary conversion.

Current signature (preserved):
```cpp
NTSTATUS UserNameToToken(
    __in PLSA_UNICODE_STRING AccountName,
    __out PLSA_TOKEN_INFORMATION_V2 *Token,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus)
```

Steps:
1. Add #include "ErrorHandling.h" if not present

2. Create internal function returning Result<PLSA_TOKEN_INFORMATION_V2>:
```cpp
[[nodiscard]] EID::Result<PLSA_TOKEN_INFORMATION_V2> UserNameToTokenInternal(
    __in PLSA_UNICODE_STRING AccountName,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus) noexcept
{
    // Move existing UserNameToToken implementation here
    // Convert "Status = STATUS_*; __leave;" to "return EID::make_unexpected(HRESULT_FROM_NT(Status))"
    // Convert "*Token = ...; return STATUS_SUCCESS;" to "*TokenLength = ...; return value;"

    // Note: Need HRESULT_FROM_NT macro or mapping for NTSTATUS -> HRESULT
    // For now, convert NTSTATUS to HRESULT via: return EID::make_unexpected(static_cast<HRESULT>(Status))
}
```

3. Replace exported UserNameToToken with wrapper:
```cpp
NTSTATUS UserNameToToken(
    __in PLSA_UNICODE_STRING AccountName,
    __out PLSA_TOKEN_INFORMATION_V2 *Token,
    __out PDWORD TokenLength,
    __out PNTSTATUS SubStatus)
{
    auto result = UserNameToTokenInternal(AccountName, TokenLength, SubStatus);
    if (result) {
        *Token = *result;
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```

Note: CompleteToken.cpp may need HRESULT_FROM_NT macro if not defined. Add if needed:
```cpp
#define HRESULT_FROM_NT(x) ((HRESULT) ((x) | FACILITY_NT_BIT))
```

CRITICAL: Mark UserNameToTokenInternal with noexcept (LSASS compatibility requirement)
  </action>
  <verify>
Build EIDCardLibrary and verify UserNameToToken links correctly
Test that NTSTATUS return values match original behavior
Verify with grep: "UserNameToTokenInternal.*noexcept" confirms noexcept marker present
  </verify>
  <done>UserNameToTokenInternal returns Result<PLSA_TOKEN_INFORMATION_V2> with noexcept, exported UserNameToToken uses hr_to_ntstatus()</done>
</task>

<task type="auto">
  <name>Task 5: Refactor CheckAuthorization with NTSTATUS conversion</name>
  <files>EIDCardLibrary/CompleteToken.cpp</files>
  <action>
Refactor CheckAuthorization() in CompleteToken.cpp to use internal Result<T> with NTSTATUS boundary conversion.

Current signature (preserved):
```cpp
NTSTATUS CheckAuthorization(PWSTR UserName, NTSTATUS *SubStatus, LARGE_INTEGER *ExpirationTime)
```

Steps:
1. Create internal function:
```cpp
[[nodiscard]] EID::Result<LARGE_INTEGER> CheckAuthorizationInternal(
    PWSTR UserName,
    NTSTATUS* SubStatus) noexcept
{
    // Move existing CheckAuthorization implementation here
    // Return ExpirationTime on success
    // Convert "return Status" errors to "return EID::make_unexpected(HRESULT_FROM_NT(Status))"
}
```

2. Replace exported CheckAuthorization with wrapper:
```cpp
NTSTATUS CheckAuthorization(PWSTR UserName, NTSTATUS *SubStatus, LARGE_INTEGER *ExpirationTime)
{
    auto result = CheckAuthorizationInternal(UserName, SubStatus);
    if (result) {
        *ExpirationTime = *result;
        return STATUS_SUCCESS;
    }
    return EID::hr_to_ntstatus(result.error());
}
```

Note: CheckAuthorization likely calls NameToSid, GetGroups, etc. Those remain BOOL functions for now (future phases may migrate them).

CRITICAL: Mark CheckAuthorizationInternal with noexcept (LSASS compatibility requirement)
  </action>
  <verify>
Build EIDCardLibrary and verify CheckAuthorization links correctly
Test that NTSTATUS return values and ExpirationTime output match original behavior
Verify with grep: "CheckAuthorizationInternal.*noexcept" confirms noexcept marker present
  </verify>
  <done>CheckAuthorizationInternal returns Result<LARGE_INTEGER> with noexcept, exported CheckAuthorization uses hr_to_ntstatus()</done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 6: Verify API boundary conversion layer</name>
  <what-built>Complete API boundary conversion layer with internal Result<T> functions (all marked noexcept) and exported C-style wrappers</what-built>
  <how-to-verify>
1. Build EIDCardLibrary project (all configurations: Debug|Release x Win32|x64)
2. Verify zero compile errors and zero warnings
3. Inspect exported functions using dumpbin /EXPORTS:
   ```
   dumpbin /EXPORTS EIDCardLibrary.lib
   ```
   Verify exported signatures match original (HRESULT, BOOL, NTSTATUS - no std::expected in exports)
4. Test call chains:
   - Call HasCertificateRightEKU with valid cert -> returns TRUE
   - Call HasCertificateRightEKU with invalid cert -> returns FALSE, check GetLastError() for error code
   - Call ValidateCertificate with valid cert -> returns S_OK
   - Call ValidateCertificate with invalid cert -> returns error HRESULT
   - Call GetCertificateFromCspInfo with valid CSP info -> returns S_OK with certificate
5. Verify error propagation:
   - Internal errors correctly convert to HRESULT at boundary
   - NTSTATUS functions correctly map HRESULT errors via hr_to_ntstatus()
6. Verify noexcept compliance:
   ```
   grep -E "Internal.*noexcept" EIDCardLibrary/CertificateValidation.cpp EIDCardLibrary/CertificateUtilities.cpp EIDCardLibrary/CompleteToken.cpp
   ```
   All internal functions should have noexcept marker
  </how-to-verify>
  <resume-signal>Type "approved" to continue or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. All exported function signatures unchanged (HRESULT, BOOL, NTSTATUS)
2. Internal functions use EID::Result<T> with [[nodiscard]] and noexcept
3. Boundary conversions use EID::to_bool() for BOOL wrappers
4. Boundary conversions use EID::hr_to_ntstatus() for NTSTATUS wrappers
5. Error codes propagate correctly through conversion layer
6. No exceptions thrown in LSASS context (all internal functions marked noexcept)
7. Grep verification confirms noexcept markers on all internal functions
</verification>

<success_criteria>
1. HasCertificateRightEKU, ValidateCertificate migrated to Result<T> pattern with noexcept
2. GetCertificateFromCspInfo migrated to Result<T> pattern with noexcept
3. UserNameToToken, CheckAuthorization migrated to Result<T> pattern with NTSTATUS conversion and noexcept
4. All exported functions maintain C-style signatures
5. Zero compile errors across all configurations
6. All internal functions verified to have noexcept marker (ERROR-03 compliance)
7. Error propagation verified correct (GetLastError, HRESULT, NTSTATUS all set correctly)
8. Ready for Phase 3 (Compile-Time Enhancements)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-03-SUMMARY.md`
</output>
