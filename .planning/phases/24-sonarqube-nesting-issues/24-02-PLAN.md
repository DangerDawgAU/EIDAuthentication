---
phase: 24-sonarqube-nesting-issues
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - EIDCardLibrary/CSmartCardNotifier.cpp
  - EIDCardLibrary/CertificateUtilities.cpp
autonomous: true
requirements:
  - SONAR-04
user_setup: []

must_haves:
  truths:
    - "WaitForSmartCardInsertion has reduced nesting with early continue pattern"
    - "SelectFirstCertificateWithPrivateKey uses early continue in loop"
    - "Build passes with zero errors"
  artifacts:
    - path: "EIDCardLibrary/CSmartCardNotifier.cpp"
      provides: "Smart card event notification with reduced nesting"
      contains: "continue"
    - path: "EIDCardLibrary/CertificateUtilities.cpp"
      provides: "Certificate utilities with reduced nesting"
  key_links:
    - from: "WaitForSmartCardInsertion"
      to: "reader state checks"
      via: "continue pattern"
      pattern: "if.*continue"
---

<objective>
Reduce nesting depth in CSmartCardNotifier.cpp and CertificateUtilities.cpp using early continue/return patterns.

Purpose: Address ~18 nesting depth issues across two high-impact files using low-risk refactoring patterns.

Output: Refactored CSmartCardNotifier.cpp and CertificateUtilities.cpp with improved readability.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-sonarqube-nesting-issues/24-RESEARCH.md

@EIDCardLibrary/CSmartCardNotifier.cpp
@EIDCardLibrary/CertificateUtilities.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply early continue pattern in CSmartCardNotifier WaitForSmartCardInsertion</name>
  <files>EIDCardLibrary/CSmartCardNotifier.cpp</files>
  <action>
Refactor the main for-loop in WaitForSmartCardInsertion to use early continue pattern instead of deep nesting.

Target code section (lines ~220-267 in the for-loop):
```cpp
for (dwI = 0; dwI < dwRdrCount; dwI++)
{
    // Current deeply nested structure:
    if (!(SCARD_STATE_MUTE & rgscState[dwI].dwEventState) &&
        (SCARD_STATE_CHANGED & rgscState[dwI].dwEventState))
    {
        // Card insertion handling - 4 levels deep
        if ((SCARD_STATE_PRESENT & rgscState[dwI].dwEventState) && ...)
        {
            // Even deeper nesting
        }
        // Card removal handling
        if (!(SCARD_STATE_PRESENT & rgscState[dwI].dwEventState) && ...)
        {
            // Deep nesting
        }
    }
}
```

Refactor to:
```cpp
for (dwI = 0; dwI < dwRdrCount; dwI++)
{
    // Skip unchanged or mute readers early
    if ((SCARD_STATE_MUTE & rgscState[dwI].dwEventState) ||
        !(SCARD_STATE_CHANGED & rgscState[dwI].dwEventState))
    {
        rgscState[dwI].dwCurrentState = rgscState[dwI].dwEventState;
        continue;
    }

    EIDCardLibraryTrace(WINEVENT_LEVEL_INFO, L"SCardGetStatusChange :0x%08X", rgscState[dwI].dwEventState);

    // Handle card insertion at reduced nesting (now 2 levels instead of 4)
    if ((SCARD_STATE_PRESENT & rgscState[dwI].dwEventState) &&
        !(SCARD_STATE_PRESENT & rgscState[dwI].dwCurrentState))
    {
        // Card insertion logic - unchanged, just less nested
        LPTSTR pmszCards = nullptr;
        DWORD cch = SCARD_AUTOALLOCATE;
        // ... existing ATR trace code ...
        Status = SCardListCards(_hSCardContext, rgscState[dwI].rgbAtr, nullptr, 0, (LPTSTR)&pmszCards, &cch);
        if (Status != SCARD_S_SUCCESS)
        {
            EIDCardLibraryTrace(WINEVENT_LEVEL_WARNING, L"Unable to retrieve smart card name 0x%08x", Status);
        }
        Callback(EIDCPRSConnecting, rgscState[dwI].szReader, pmszCards, (rgscState[dwI].dwEventState) >> 16);
        SCardFreeMemory(_hSCardContext, pmszCards);
        rgscState[dwI].dwCurrentState = SCARD_STATE_PRESENT;
    }

    // Handle card removal at reduced nesting
    if (!(SCARD_STATE_PRESENT & rgscState[dwI].dwEventState) &&
        (SCARD_STATE_PRESENT & rgscState[dwI].dwCurrentState) &&
        !(SCARD_STATE_MUTE & rgscState[dwI].dwCurrentState))
    {
        Callback(EIDCPRSDisconnected, rgscState[dwI].szReader, nullptr, 0);
        rgscState[dwI].dwCurrentState = SCARD_STATE_EMPTY;
    }

    // Memorize the current state.
    rgscState[dwI].dwCurrentState = rgscState[dwI].dwEventState;
}
```

Key changes:
- Invert the outer condition and use continue to skip uninteresting readers
- Flatten card insertion and removal handling to 2 levels
- Preserve exact behavior and callbacks
  </action>
  <verify>
1. Build EIDCardLibrary project: `msbuild EIDCardLibrary.vcxproj /p:Configuration=Release /p:Platform=x64`
2. Verify no new compiler warnings
3. Manual inspection: for-loop uses continue pattern for early exit
  </verify>
  <done>
WaitForSmartCardInsertion for-loop refactored with early continue pattern. Nesting reduced from 4-5 levels to 2-3 levels. Build passes.
</done>
</task>

<task type="auto">
  <name>Task 2: Apply early continue in CertificateUtilities SelectFirstCertificateWithPrivateKey</name>
  <files>EIDCardLibrary/CertificateUtilities.cpp</files>
  <action>
Refactor SelectFirstCertificateWithPrivateKey function to use early continue pattern in the while loop.

Target code section (lines ~214-242):
```cpp
while (pCertContext)
{
    PBYTE KeySpec = nullptr;
    dwSize = 0;
    if (CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, KeySpec, &dwSize))
    {
        // Deeply nested certificate matching logic
        if (returnedContext)
            CertFreeCertificateContext(returnedContext);
        CertGetNameString(...);
        if (_tcscmp(szCertName, szComputerName) == 0)
        {
            returnedContext = pCertContext;
            break;
        }
        else
        {
            returnedContext = CertDuplicateCertificateContext(pCertContext);
        }
    }
    pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
}
```

Refactor to:
```cpp
while (pCertContext)
{
    PBYTE KeySpec = nullptr;
    dwSize = 0;

    // Skip certificates without private keys
    if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, KeySpec, &dwSize))
    {
        pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
        continue;
    }

    // Certificate has a private key - process it
    if (returnedContext)
        CertFreeCertificateContext(returnedContext);

    CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, nullptr, szCertName, ARRAYSIZE(szCertName));

    // Check for computer name match
    if (_tcscmp(szCertName, szComputerName) == 0)
    {
        returnedContext = pCertContext;
        break;  // Found exact match, exit loop
    }

    // Keep a reference to this certificate as fallback
    returnedContext = CertDuplicateCertificateContext(pCertContext);
    pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
}
```

Key changes:
- Invert the private key check and use continue to skip non-key certs
- Flatten the matching logic to 2 levels
- Preserve exact behavior (computer name match breaks, otherwise continues searching)
  </action>
  <verify>
1. Build EIDCardLibrary project: `msbuild EIDCardLibrary.vcxproj /p:Configuration=Release /p:Platform=x64`
2. Verify no new compiler warnings
3. Manual inspection: while loop uses early continue pattern
  </verify>
  <done>
SelectFirstCertificateWithPrivateKey refactored with early continue pattern. Nesting reduced from 4 levels to 2 levels. Build passes.
</done>
</task>

<task type="auto">
  <name>Task 3: Apply guard clause pattern in CSmartCardNotifier Start method</name>
  <files>EIDCardLibrary/CSmartCardNotifier.cpp</files>
  <action>
Refactor the Start() method to use guard clause pattern (already partially done, verify and ensure consistency).

Current structure is already close to correct pattern but verify it follows guard clause pattern:
```cpp
HRESULT CSmartCardConnectionNotifier::Start()
{
    EIDCardLibraryTrace(WINEVENT_LEVEL_VERBOSE, L"Enter");

    // Guard clause: no callback
    if (nullptr == _CallBack)
    {
        EIDCardLibraryTrace(WINEVENT_LEVEL_WARNING, L"No callback defined");
        return E_FAIL;
    }

    // Guard clause: already running
    if (_hThread != nullptr)
    {
        EIDCardLibraryTrace(WINEVENT_LEVEL_WARNING, L"Thread already launched");
        return E_FAIL;
    }

    // Main logic at reduced nesting level
    _hThread = CreateThread(nullptr, 0, CSmartCardConnectionNotifier::_ThreadProc, (LPVOID)this, 0, nullptr);
    if (_hThread == nullptr)
    {
        EIDCardLibraryTrace(WINEVENT_LEVEL_WARNING, L"Unable to launch the thread : %d", GetLastError());
        return E_FAIL;
    }

    _hAccessStartedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

    EIDCardLibraryTrace(WINEVENT_LEVEL_VERBOSE, L"Leave");
    return S_OK;
}
```

The current code already follows this pattern. No changes needed, just verify it's correct and document as reference pattern for other functions.
  </action>
  <verify>
1. Verify Start() method follows guard clause pattern
2. Build passes: `msbuild EIDCardLibrary.vcxproj /p:Configuration=Release /p:Platform=x64`
  </verify>
  <done>
Start() method verified to follow guard clause pattern. No changes needed - serves as reference implementation.
</done>
</task>

</tasks>

<verification>
1. Build EIDCardLibrary project successfully
2. Verify WaitForSmartCardInsertion uses early continue pattern
3. Verify SelectFirstCertificateWithPrivateKey uses early continue pattern
4. No new compiler warnings
</verification>

<success_criteria>
- WaitForSmartCardInsertion for-loop has nesting depth reduced from 4-5 to 2-3 levels
- SelectFirstCertificateWithPrivateKey while-loop has nesting depth reduced from 4 to 2 levels
- Build passes with zero errors
- Functionality preserved (same callback behavior, same certificate selection logic)
</success_criteria>

<output>
After completion, create `.planning/phases/24-sonarqube-nesting-issues/24-02-SUMMARY.md`
</output>
