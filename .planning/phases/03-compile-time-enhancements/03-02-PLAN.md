---
phase: 03-compile-time-enhancements
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - EIDCardLibrary/CertificateValidation.h
  - EIDCardLibrary/CertificateUtilities.h
  - EIDCardLibrary/CompleteToken.h
  - EIDCardLibrary/StoredCredentialManagement.h
autonomous: true

must_haves:
  truths:
    - "Validation functions that are pure logic are marked constexpr for compile-time evaluation"
    - "constexpr validation functions are also noexcept for LSASS compatibility"
    - "static_assert statements exist to validate constants at compile-time"
    - "Code compiles without errors after constexpr additions"
  artifacts:
    - path: "EIDCardLibrary/CertificateValidation.h"
      provides: "constexpr validation functions for certificate checks"
      contains: "constexpr.*noexcept"
    - path: "EIDCardLibrary/CertificateUtilities.h"
      provides: "constexpr utility functions for certificate operations"
      contains: "constexpr.*noexcept"
    - path: "EIDCardLibrary/StoredCredentialManagement.h"
      provides: "constexpr validation for PIN and credential data"
      contains: "constexpr.*noexcept"
  key_links:
    - from: "Validation function declarations"
      to: "constexpr specifier"
      via: "Function signature modification"
      pattern: "constexpr\\s+\\w+\\s+\\w+\\s*\\([^)]*\\)\\s+noexcept"
    - from: "Compile-time validation"
      to: "static_assert"
      via: "Compile-time assertion of constexpr results"
      pattern: "static_assert\\s*\\("
---

<objective>
Extend constexpr to validation routines enabling compile-time evaluation and early error detection for constant values.

Purpose: Enable compile-time validation of constants and improve optimization opportunities. C++23 relaxed constexpr restrictions (P2448R2) allowing more functions to be constexpr. All constexpr functions in LSASS context should also be noexcept per Phase 2 decision.

Output: Validation functions marked constexpr+noexcept where beneficial, with static_assert usage for compile-time constant validation.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-compile-time-enhancements/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify and audit validation functions for constexpr candidates</name>
  <files>EIDCardLibrary/CertificateValidation.h, EIDCardLibrary/CertificateUtilities.h, EIDCardLibrary/StoredCredentialManagement.h</files>
  <action>
    Search for validation functions in the codebase that can be made constexpr:

    1. Look for functions that:
       - Perform simple comparisons (length checks, bounds checks)
       - Don't call Windows APIs (which aren't constexpr)
       - Don't allocate memory dynamically
       - Return simple types (bool, int, size_t)

    2. Target patterns (grep for candidates):
       - Functions named "validate", "check", "is_valid", "has_valid"
       - Functions comparing constants (PIN length, buffer sizes, hash lengths)
       - Range checking functions

    3. Read the identified functions and verify they:
       - Contain only simple logic (comparisons, arithmetic)
       - Don't use non-constexpr operations
       - Can be made both constexpr AND noexcept

    Document findings: Which functions can be made constexpr, which cannot (and why).

    Example candidates from research:
    - PIN length validation (min/max constants)
    - Buffer size validation
    - Certificate hash length validation (SHA-256 = 32 bytes)
  </action>
  <verify>grep -rn "bool.*validate\|bool.*is_valid\|bool.*check" EIDCardLibrary/*.h | head -20</verify>
  <done>List of validation functions that are candidates for constexpr, with rationale for each</done>
</task>

<task type="auto">
  <name>Task 2: Add constexpr+noexcept to identified validation functions</name>
  <files>EIDCardLibrary/CertificateValidation.h, EIDCardLibrary/StoredCredentialManagement.h</files>
  <action>
    For each validation function identified in Task 1 that is suitable for constexpr:

    1. Modify function signature to add BOTH constexpr AND noexcept:
       Before: `bool is_valid_pin_length(size_t length)`
       After:  `constexpr bool is_valid_pin_length(size_t length) noexcept`

    2. Only modify functions that:
       - Are pure validation logic (no Windows API calls)
       - Have simple return statements
       - Don't throw or require exception handling

    3. Common patterns to make constexpr:
       - Range checks: `return value >= min && value <= max`
       - Length checks: `return length == expected_length`
       - Flag checks: `return (flags & mask) != 0`

    4. DO NOT make constexpr if function:
       - Calls Windows APIs (e.g., CryptAcquireContext, CertVerifyCertificate)
       - Uses static local variables with non-constexpr initialization
       - Has complex control flow that can't be evaluated at compile-time

    Note: The order of specifiers matters: `constexpr` comes before return type, `noexcept` comes after parameter list.
  </action>
  <verify>grep -n "constexpr.*noexcept" EIDCardLibrary/CertificateValidation.h EIDCardLibrary/StoredCredentialManagement.h</verify>
  <done>Appropriate validation functions now marked with constexpr+noexcept</done>
</task>

<task type="auto">
  <name>Task 3: Add static_assert for compile-time constant validation</name>
  <files>EIDCardLibrary/StoredCredentialManagement.h, EIDCardLibrary/CertificateValidation.h</files>
  <action>
    Add static_assert statements to validate constants at compile-time using the newly-constexpr validation functions:

    1. Identify constant values that should be validated:
       - PIN length constants (min/max)
       - Buffer size constants
       - Certificate hash lengths
       - Any other security-critical constants

    2. For each constant, add a static_assert:
       ```cpp
       constexpr size_t MIN_PIN_LENGTH = 4;
       constexpr size_t MAX_PIN_LENGTH = 16;
       static_assert(is_valid_pin_length(MIN_PIN_LENGTH), "MIN_PIN_LENGTH must be valid");
       static_assert(is_valid_pin_length(MAX_PIN_LENGTH), "MAX_PIN_LENGTH must be valid");
       ```

    3. Place static_assert statements:
       - After constant definitions
       - Before first use of the constant
       - In the same header as the constant/constexpr function

    4. If no suitable constants exist for static_assert, document this finding and proceed.

    The value here is catching constant misconfigurations at compile-time rather than runtime.
  </action>
  <verify>grep -n "static_assert" EIDCardLibrary/StoredCredentialManagement.h EIDCardLibrary/CertificateValidation.h | grep -v "//"</verify>
  <done>Compile-time assertions added for security-critical constants</done>
</task>

<task type="auto">
  <name>Task 4: Verify build succeeds with constexpr additions</name>
  <files>EIDCardLibrary.vcxproj</files>
  <action>
    Build EIDCardLibrary project to verify that constexpr changes compile successfully.

    Command: msbuild EIDCardLibrary/EIDCardLibrary.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:ClCompile

    Expect: Build succeeds. If constexpr causes errors, the function likely uses non-constexpr operations.

    If build fails with constexpr errors:
    - The error message will indicate which operation isn't constexpr
    - Either remove constexpr from that function, or refactor to avoid the non-constexpr operation
    - Document the decision: Function X cannot be constexpr because it calls Y
  </action>
  <verify>msbuild EIDCardLibrary/EIDCardLibrary.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:ClCompile 2>&1 | tail -20</verify>
  <done>Build succeeds with all constexpr validation functions, no new errors introduced</done>
</task>

</tasks>

<verification>
Overall phase verification:

1. At least 2-3 validation functions are now constexpr+noexcept
2. static_assert statements validate constants at compile-time
3. Build succeeds without errors
4. grep confirms constexpr and noexcept specifiers are paired correctly
5. Functions that CANNOT be constexpr are documented (if any)
</verification>

<success_criteria>
1. Pure validation functions marked constexpr+noexcept where applicable
2. Compile-time validation via static_assert for security-critical constants
3. No regression in build success
4. Clear documentation of which functions were made constexpr and why
</success_criteria>

<output>
After completion, create `.planning/phases/03-compile-time-enhancements/03-02-SUMMARY.md`
</output>
