---
phase: 03-compile-time-enhancements
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - EIDCardLibrary/CertificateValidation.h
  - EIDCardLibrary/CertificateUtilities.h
  - EIDCardLibrary/StoredCredentialManagement.h
  - EIDCardLibrary/EIDCardLibrary.h
autonomous: true

must_haves:
  truths:
    - "if consteval used where compile-time vs runtime code paths differ"
    - "std::unreachable() ONLY used on truly unreachable paths (exhaustive switch defaults)"
    - "No std::unreachable on error handling or security validation paths"
    - "Code compiles without errors after if consteval and std::unreachable additions"
  artifacts:
    - path: "EIDCardLibrary/CertificateValidation.h"
      provides: "if consteval usage in validation functions (if applicable)"
      contains: "if consteval"
    - path: "EIDCardLibrary/EIDCardLibrary.h"
      provides: "std::unreachable() in exhaustive switch statements (if any exist)"
      contains: "std::unreachable"
  key_links:
    - from: "Compile-time path"
      to: "if consteval block"
      via: "Language feature for compile-time detection"
      pattern: "if\\s+consteval\\s*\\{"
    - from: "Exhaustive switch default"
      to: "std::unreachable()"
      via: "Optimization hint for impossible code paths"
      pattern: "default:\\s*\\{[^}]*std::unreachable"
---

<objective>
Apply `if consteval` for compile-time vs runtime path differentiation and `std::unreachable()` for truly impossible code paths (with extreme caution).

Purpose: Enable optimized compile-time code paths and provide optimization hints for impossible branches. Per research, `if consteval` requires VS 2022 17.14+ and `std::unreachable()` is DANGEROUS in security code - must ONLY be used on exhaustive switch defaults with ALL enum cases handled.

Output: if consteval used where beneficial, std::unreachable used ONLY on provably unreachable paths, documented justification for each use.
</objective>

<execution_context>
@C:/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-compile-time-enhancements/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify candidates for if consteval usage</name>
  <files>EIDCardLibrary/CertificateValidation.h, EIDCardLibrary/StoredCredentialManagement.h</files>
  <action>
    Search for functions that could benefit from compile-time vs runtime differentiation:

    1. Look for functions that:
       - Are already constexpr (from 03-02)
       - Have different optimal implementations for compile-time vs runtime
       - Currently use std::is_constant_evaluated() (can be replaced with if consteval)
       - Have simple compile-time paths but more complex runtime paths

    2. Good candidates for if consteval:
       - Validation that could read from policy at runtime but uses constants at compile-time
       - Functions that do stricter checks at compile-time vs runtime
       - Algorithms with different implementations for constant vs variable inputs

    3. Search pattern:
       grep -rn "std::is_constant_evaluated" EIDCardLibrary/
       grep -rn "constexpr.*validate\|constexpr.*check" EIDCardLibrary/*.h

    4. Document findings:
       - List functions that could use if consteval
       - Explain why each would benefit (compile-time path vs runtime path)
       - Note if no good candidates exist (this is acceptable - if consteval is niche)

    Note: Per research, if consteval was added in VS 2022 17.14 (May 2025). Verify toolset supports it.
  </action>
  <verify>grep -rn "std::is_constant_evaluated\|constexpr.*validate" EIDCardLibrary/*.h | head -10</verify>
  <done>Documented list of functions that could benefit from if consteval, or justification if none applicable</done>
</task>

<task type="auto">
  <name>Task 2: Apply if consteval where beneficial</name>
  <files>EIDCardLibrary/CertificateValidation.h, EIDCardLibrary/StoredCredentialManagement.h</files>
  <action>
    For each function identified in Task 1 that would benefit from if consteval:

    1. Modify the function to use if consteval:
       ```cpp
       constexpr bool validate_hash_length(size_t length) noexcept {
           if consteval {
               // Compile-time path: strict constant check
               return length == 32;  // SHA-256 hash length
           } else {
               // Runtime path: could read from config or policy
               return length == 32;  // Or: read from registry/Config
           }
       }
       ```

    2. Use if consteval (NOT if (std::is_constant_evaluated()))
       - if consteval is a statement, not an expression
       - Cleaner syntax: `if consteval { ... } else { ... }`

    3. Only apply where paths genuinely differ:
       - If compile-time and runtime paths are identical, if consteval adds no value
       - Good use case: compile-time uses constants, runtime reads from policy/config
       - Good use case: compile-time does strict validation, runtime is more lenient

    4. If no suitable candidates found, document this and proceed to Task 3.

    Safety: if consteval cannot introduce security issues - it only affects WHEN code runs, not WHAT it does.
  </action>
  <verify>grep -n "if consteval" EIDCardLibrary/CertificateValidation.h EIDCardLibrary/StoredCredentialManagement.h</verify>
  <done>if consteval applied where compile-time vs runtime paths differ, or documented as not applicable</done>
</task>

<task type="auto">
  <name>Task 3: Identify exhaustive switch statements for std::unreachable</name>
  <files>EIDCardLibrary/EIDCardLibrary.h, EIDCardLibrary/StoredCredentialManagement.cpp, EIDCardLibrary/CompleteToken.cpp</files>
  <action>
    Search for switch statements that could benefit from std::unreachable():

    1. Look for switch statements over enum types:
       grep -rn "switch.*EID_" EIDCardLibrary/*.cpp EIDCardLibrary/*.h
       grep -rn "switch.*GPOPolicy\|switch.*CheckType\|switch.*SAMPLE_FIELD" EIDCardLibrary/*.cpp EIDCredentialProvider/*.cpp

    2. For each switch found, verify:
       - Does it handle ALL enum cases explicitly?
       - Is there a default case?
       - Is the default truly unreachable (all cases handled)?

    3. SAFE use of std::unreachable:
       - Exhaustive switch: All enum values have explicit case labels
       - Default case: Only exists to satisfy compiler, never executes
       - No enum coercion: Switch variable is actual enum, not cast from int

    4. DANGEROUS - DO NOT use std::unreachable:
       - Switch statements with missing enum cases
       - Default cases that handle unexpected values
       - Error handling paths (these CAN be reached)
       - Security validation failures (attackers might trigger)
       - Any code depending on external input

    5. Document findings:
       - List switches that are candidates for std::unreachable
       - Explain why each is safe (all enum cases handled)
       - Note if no safe candidates exist

    CRITICAL: If unsure about a switch, DO NOT add std::unreachable. Default to safe behavior.
  </action>
  <verify>grep -rn "switch.*case.*default:" EIDCardLibrary/*.cpp | head -10</verify>
  <done>Documented list of safe exhaustive switches, or justification if none suitable</done>
</task>

<task type="auto">
  <name>Task 4: Apply std::unreachable() to safe exhaustive switches</name>
  <files>EIDCardLibrary/EIDCardLibrary.h, EIDCardLibrary/StoredCredentialManagement.cpp, EIDCardLibrary/CompleteToken.cpp</files>
  <action>
    For each exhaustive switch identified in Task 3 that is provably safe:

    1. Add std::unreachable() to the default case:
       ```cpp
       const char* get_message_name(EID_CALLPACKAGE_MESSAGE msg) noexcept {
           switch (msg) {
               case EID_CALLPACKAGE_MESSAGE::Message:
                   return "Message";
               case EID_CALLPACKAGE_MESSAGE::CardInserted:
                   return "CardInserted";
               case EID_CALLPACKAGE_MESSAGE::CardRemoved:
                   return "CardRemoved";
               default:
                   // SAFE: All enum values handled above
                   std::unreachable();
           }
       }
       ```

    2. CRITICAL SAFETY CHECKS before adding std::unreachable():
       - [ ] ALL enum values have explicit case labels
       - [ ] Enum is scoped (enum class) or unscoped but fully covered
       - [ ] No integer casting to enum type in surrounding code
       - [ ] Default case would NEVER execute in correct usage
       - [ ] NOT in security-critical validation code
       - [ ] NOT in error handling paths

    3. If ANY safety check fails, DO NOT add std::unreachable.
       Use return or break in default case instead.

    4. Add comment explaining WHY unreachable is safe:
       `// All enum cases handled above - this path is unreachable`

    5. If no safe switches found, document this and proceed to verification.

    Remember: std::unreachable() triggers undefined behavior if executed. In security-critical LSASS code, prefer safe defaults over optimization hints.
  </action>
  <verify>grep -n "std::unreachable" EIDCardLibrary/*.h EIDCardLibrary/*.cpp 2>/dev/null | head -5</verify>
  <done>std::unreachable() applied ONLY to exhaustive switches with all cases handled, or documented as not applicable</done>
</task>

<task type="auto">
  <name>Task 5: Verify build succeeds with if consteval and std::unreachable</name>
  <files>EIDCardLibrary.vcxproj</files>
  <action>
    Build EIDCardLibrary project to verify that if consteval and std::unreachable changes compile successfully.

    Command: msbuild EIDCardLibrary/EIDCardLibrary.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:ClCompile

    Expect: Build succeeds. If errors occur:
    - if consteval error: Toolset may be too old (requires VS 2022 17.14+)
    - std::unreachable error: May be missing <utility> header (added in 03-01)

    Verify:
    - No new compile errors introduced
    - if consteval blocks compile correctly (if used)
    - std::unreachable() is recognized (if used)
  </action>
  <verify>msbuild EIDCardLibrary/EIDCardLibrary.vcxproj /p:Configuration=Debug /p:Platform=x64 /t:ClCompile 2>&1 | tail -20</verify>
  <done>Build succeeds with if consteval and std::unreachable changes, no new errors</done>
</task>

</tasks>

<verification>
Overall phase verification:

1. if consteval used where compile-time vs runtime paths genuinely differ (or documented as N/A)
2. std::unreachable() ONLY used in exhaustive switch defaults with all enum cases handled (or documented as N/A)
3. No std::unreachable() on error handling or security validation paths
4. Build succeeds without errors
5. <utility> header is included (from 03-01) if std::unreachable is used
6. All std::unreachable uses have safety comments
</verification>

<success_criteria>
1. if consteval applied where beneficial, with clear rationale
2. std::unreachable used ONLY on provably unreachable paths, with safety justification
3. No std::unreachable on security-critical or error-handling paths
4. Build succeeds without errors
5. Conservative approach: missing optimizations preferred over unsafe unreachable
</success_criteria>

<output>
After completion, create `.planning/phases/03-compile-time-enhancements/03-03-SUMMARY.md`
</output>
